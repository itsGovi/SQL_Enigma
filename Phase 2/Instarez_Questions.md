Below are the updated versions of all your practice questions—with each one modified to push your PostgreSQL skills further by incorporating advanced techniques. These revisions require you to work with recursive CTEs, advanced window functions, complex joins (including full outer joins and cross joins), JSON and regular expression functions, materialized views, user-defined functions, triggers, stored procedures, and more. Use these as targets for your practice and exploration!

---

### **Enhanced Basic & Intermediate Query Challenges**

1. **Enhanced Department Training Analysis with Recursive CTEs and Running Totals ✅**

   **Objective:**

   * For each region, identify the top 3 departments (with at least 10 employees) where the average training hours of entry‑level employees have not only exceeded the overall median training hours (computed over the past 3 years) but have also shown a consistent upward trend.

     **Requirements:**
   * Use a recursive CTE to calculate the year‑over‑year running average of training hours for each department.
   * Compute the overall median training hours over the last 3 years using `PERCENTILE_CONT()` within a window function.
   * Partition by region and filter departments with increasing training hours, then rank by the latest year’s average training hours (with a tie-breaker on employee count).

     **Return:** Department name, region, latest year’s average training hours, and employee count.
2. **Client Services Billing Rate Analysis Using Advanced Joins and Partitioning**

   **Objective:**
   Calculate the total billing rate generated by employees in the Client Services department, grouped by region and further segmented into remote work ratio categories (for example, 0–25%, 26–50%, etc.).

   **Requirements:**

   * **Data Filtering:**
     * Limit your analysis to employees in the Client Services department.
   * **Remote Work Ratio Bucketing:**
     * Use a CASE expression (or create a CTE) to bucket the `remote_work_ratio` into predefined categories (e.g., 0–25%, 26–50%, etc.).
   * **Aggregation and Advanced Joins:**
     * Use aggregation (such as `SUM()`) to calculate the total billing rate for each remote work ratio category within each region.
     * Incorporate advanced join techniques if you simulate or need to merge additional details (for example, performing a self-join to ensure that employees who might not fall into any standard bucket are still included).
   * **Partitioning and Percentage Calculation:**
     * Partition the data by region to calculate, for each region, the percentage contribution of each remote work ratio category to the region’s overall billing rate.

   **Return:**

   * Region
   * Remote work ratio category (e.g., “0–25%”, “26–50%”, etc.)
   * Total billing rate (sum) for that category
   * Percentage contribution of that category relative to the overall billing rate in the region
3. **Dynamic Project Duration Comparison in APAC with LAG/LEAD and Advanced Aggregation**

   **Objective:**

   * For APAC-region employees, display those whose average project duration exceeds the departmental average and show the differences compared to their immediate peers (using LAG and LEAD).

     **Requirements:**
   * Calculate the departmental average project duration with a CTE.
   * Use LAG/LEAD window functions to compute the difference from the previous and next employees (ordered by project duration) within each department.

     **Return:** Employee name, department, individual project duration, departmental average, difference from previous, and difference from next record.
4. **Comprehensive Risk Analysis with Full Outer Joins and JSON Extraction**

   **Objective:**

   * Identify employees with flight risk below 20 and span of control above 3. Also, enrich this data by joining with a JSON-based risk factors table that adds external risk scores.

     **Requirements:**
   * Use a full outer join to include employees even if JSON data is missing.
   * Apply PostgreSQL JSON functions to extract additional risk factors and calculate a consolidated risk score.

     **Return:** Employee id, full name, computed risk score, flight risk, and span of control.
5. **Utilization Ranking Across Job Levels with DENSE_RANK and Difference Calculations**

   **Objective:**

   * Rank employees by their actual utilization within each job level and department, then display the gap between each employee’s utilization and the top utilization in their partition.

     **Requirements:**
   * Use DENSE_RANK() partitioned by department and job level ordered by actual utilization (DESC).
   * Utilize window functions (like MAX() OVER) to compute the difference relative to the highest utilization in the group.

     **Return:** Employee id, job level, department, actual utilization, rank, and difference to the top utilization.
6. **Top 10% Knowledge Sharers with PERCENTILE_DISC and Conditional Classification**

   **Objective:**

   * List employees whose knowledge sharing score falls in the top 10% of their department and tag them using a CASE statement.

     **Requirements:**
   * Use PERCENTILE_DISC(0.9) WITHIN GROUP (ORDER BY knowledge_sharing_score) to calculate the threshold per department.
   * Filter employees exceeding that threshold, and use a CASE expression to label them as “Top Sharer.”

     **Return:** Employee id, full name, department, knowledge sharing score, and the “Top Sharer” label.
7. **Certification Analysis with Regular Expressions and Conditional Aggregation**

   **Objective:**

   * Compute the percentage of employees in each primary specialization who have obtained more than one certification, accounting for inconsistent certification formatting using regular expressions.

     **Requirements:**
   * Use regex functions (like `regexp_split_to_array`) to properly parse certification strings.
   * Employ conditional aggregation (using CASE) to count employees with multiple certifications.

     **Return:** Specialization, total employee count, count of employees with >1 certification, and the percentage.
8. **Utilization Gap Minimization with Materialized Views and Indexing Strategies**

   **Objective:**

   * Identify departments with the smallest average gap between utilization target and actual utilization.

     **Requirements:**
   * Compute the gap per employee and aggregate these per department.
   * Create a materialized view to store these results and suggest an indexing strategy (e.g., a B-tree index on department and gap) for performance tuning.

     **Return:** Department name, average gap, and a brief recommendation for indexing.
9. **Advanced EMEA Employee Sorting Using Complex CASE and NULL Handling**

   **Objective:**

   * Display employees in the EMEA region sorted by a custom retention risk level (computed using a CASE expression) and then by delivery quality, while ensuring proper handling of NULL values.

     **Requirements:**
   * Use CASE to assign numeric values to retention risk categories and handle NULLs explicitly.

     **Return:** Employee id, full name, computed retention risk level, and delivery quality.
10. **Project Complexity Trends by Hire Year Using Recursive CTEs and Year-over-Year Comparison**

    **Objective:**

    * Calculate the average project complexity for each hire year and track year-over-year changes across regions using a recursive CTE.

      **Requirements:**
    * Extract the hire year and use a recursive CTE to compute the percentage change from the previous year.

      **Return:** Hire year, region, average project complexity, and YoY percentage change.
11. **Direct Reports & Satisfaction Analysis with Ranking and Window Functions**

    **Objective:**

    * Identify employees with more than 5 direct reports and average project satisfaction below 70, and then rank them within their department by project satisfaction.

      **Requirements:**
    * Filter by direct reports and satisfaction, then use a window function (e.g., RANK()) partitioned by department.

      **Return:** Employee id, full name, department, direct reports, project satisfaction, and rank.
12. **Performance Ranking by Primary Specialization with Full Outer Joins Across Regions**

    **Objective:**

    * List the top 5 primary specializations by average performance score for entry-level employees, and compare these scores across regions using full outer joins to merge regional and overall data.

      **Requirements:**
    * Aggregate performance scores by specialization and region, then rank and merge results using advanced join techniques.

      **Return:** Primary specialization, region, average performance score, and overall rank.
13. **High Flight Risk Analysis Using Subqueries and Cross Joins**

    **Objective:**

    * Identify the employees with the highest flight risk and then calculate their average training hours, using a subquery to determine the flight risk threshold and a cross join to merge with training data.

      **Requirements:**
    * Use a subquery to find the maximum flight risk and then join this with training hour aggregates.

      **Return:** Employee id, full name, flight risk, and average training hours.

---

### **Advanced & Macro-Level Query Challenges**

21. **Multi-Dimensional Delivery Quality Comparison with Pivoting Techniques**

    **Objective:**

    * Compare the average delivery quality across job levels and regions. Pivot the results so that each region appears as a separate column.

      **Requirements:**
    * Use window functions and, if available, the `crosstab` function (from the tablefunc module) for pivoting.

      **Return:** Job level with delivery quality values per region.
22. **Time-Series Training Trends for Senior Design & UX Using Recursive CTEs**

    **Objective:**

    * Analyze monthly training hours trends for senior employees in the Design & UX department.

      **Requirements:**
    * Generate a time series of months with a recursive CTE, join it with aggregated training hours, and calculate month-over-month changes using window functions.

      **Return:** Month, average training hours, and percentage change.
23. **Agile Certification Impact on Project Duration with JSON Aggregation**

    **Objective:**

    * For employees holding certifications related to Agile (detected via a JSON field or pattern matching), compute the average project duration.

      **Requirements:**
    * Use JSON extraction functions (or regex with `LIKE`) to filter Agile certifications, then aggregate project duration.

      **Return:** Certification, average project duration, and employee count.
24. **Consistent High Utilization in Product Strategy with Recursive CTEs**

    **Objective:**

    * Identify employees in the Product Strategy department who have maintained an actual utilization above 90% over multiple consecutive years.

      **Requirements:**
    * Use a recursive CTE to trace utilization across years and window functions to assign a consistency score.

      **Return:** Employee id, full name, and consistency score.
25. **Correlation Analysis Between Knowledge Sharing and Promotion Readiness**

    **Objective:**

    * Analyze the relationship between knowledge sharing scores and promotion readiness across departments by computing a correlation coefficient.

      **Requirements:**
    * Create a user-defined aggregate function or use statistical extensions if available to compute the Pearson correlation coefficient.

      **Return:** Department and correlation coefficient with an interpretation of the result.
26. **Digital Transformation Team Size Analysis with Partitioning and Advanced Indexing**

    **Objective:**

    * Compare the average team sizes for employees in Digital Transformation across regions.

      **Requirements:**
    * Use table partitioning (or a hint for indexing strategy) to optimize grouping, and compute variances using window functions.

      **Return:** Region, average team size, and variance.
27. **Innovation vs. Complexity Correlation Using Advanced Aggregates**

    **Objective:**

    * Compute the correlation between average innovation scores and average project complexity across departments.

      **Requirements:**
    * Leverage window functions and, if needed, a user-defined function to compute correlation coefficients.

      **Return:** Department, correlation coefficient, and sample size.
28. **Certification Impact Ranking in Engineering Delivery with Advanced Window Functions**

    **Objective:**

    * Rank certifications by their impact on average project duration for employees in the Engineering Delivery department.

      **Requirements:**
    * Parse and join certification data, aggregate project durations, and use a window function (e.g., RANK()) to rank certifications.

      **Return:** Certification, average project duration impact, and rank.
29. **Mid-Level Engagement Analysis with Rolling Averages and Window Frames**

    **Objective:**

    * Identify mid-level employees with the highest average engagement scores over a rolling 12‑month period.

      **Requirements:**
    * Use window functions with a defined frame (e.g., RANGE BETWEEN INTERVAL '12 months' PRECEDING AND CURRENT ROW) to calculate rolling averages.

      **Return:** Employee id, full name, and rolling average engagement score.
30. **Industry Expertise Salary Trends with Materialized Views and Partitioning**

    **Objective:**

    * Explore average base salary trends for employees grouped by industry expertise and job level over the past 5 years.

      **Requirements:**
    * Create a materialized view to pre-aggregate the data, partition the data by year or job level, and query the view for trends.

      **Return:** Industry expertise, job level, average base salary, and trend data.
31. **Utilization and Billing Analysis with Advanced Window Functions**

    **Objective:**

    * List departments with the highest average actual utilization and analyze their billing rate trends using window functions to capture fluctuations.

      **Requirements:**
    * Use window functions to compute department-level aggregates and rank the departments.

      **Return:** Department, average actual utilization, average billing rate, and rank.
32. **Project Satisfaction Trends in Large Span of Control Using Recursive CTEs**

    **Objective:**

    * Compute the average project satisfaction for employees with a span of control labeled “Large” and track changes over time using a recursive CTE.

      **Requirements:**
    * Create a recursive CTE to generate a time series and join it with satisfaction aggregates.

      **Return:** Department, time period, and average project satisfaction.
33. **Low Retention Risk Certification Evaluation with Subqueries and JSON Functions**

    **Objective:**

    * Identify certifications associated with the lowest retention risk and report their average performance scores.

      **Requirements:**
    * Use subqueries and JSON extraction functions (if certification details are stored as JSON) to filter certifications, then rank using window functions.

      **Return:** Certification, average performance score, and retention risk ranking.
34. **Remote Work Delivery Quality Comparison with Advanced CASE and Custom Sorting**

    **Objective:**

    * Compare the delivery quality of employees by categorizing them into remote work ratio buckets (above and below 30%) using a CASE statement, then order the results with a custom sort order that handles NULLs.

      **Requirements:**
    * Use CASE for categorization and advanced ORDER BY clauses.

      **Return:** Remote work category, average delivery quality, and employee count.
35. **Engagement Trends Post-Promotion Using Recursive CTEs and LAG/LEAD**

    **Objective:**

    * Analyze average engagement score trends for employees who transitioned to higher job levels over time.

      **Requirements:**
    * Use a recursive CTE to identify promotion events and LAG/LEAD to compare engagement scores before and after promotions.

      **Return:** Employee id, previous and current job levels, engagement scores pre- and post-promotion, and the difference.
36. **Managerial Project Satisfaction with JSON Joins and Advanced Aggregation**

    **Objective:**

    * Compute the average project satisfaction for employees managed by each manager. Assume manager details are stored in a separate JSON field.

      **Requirements:**
    * Join the employee table with the JSON table containing manager information, then aggregate project satisfaction.

      **Return:** Manager id, average project satisfaction, and employee count.
37. **Billing Patterns by Industry Expertise Using Full Outer Joins**

    **Objective:**

    * Explore average billing rate patterns for employees grouped by industry expertise across different regions by performing full outer joins between region-specific aggregates.

      **Requirements:**
    * Use full outer joins to merge regional aggregates and compute overall averages.

      **Return:** Industry expertise, regional billing rates, and overall averages.
38. **Training vs. Innovation Correlation with User-Defined Functions**

    **Objective:**

    * Identify departments where average training hours strongly correlate with average innovation scores.

      **Requirements:**
    * Write a user-defined scalar function to calculate Pearson’s correlation coefficient at the department level and apply it to the aggregated data.

      **Return:** Department, correlation coefficient, and significance level.
39. **Certification Ranking in Product Architecture Using Advanced Window Functions**

    **Objective:**

    * Rank certifications by their average project satisfaction within the Product Architecture department using advanced window functions and partitioning.

      **Requirements:**
    * Aggregate project satisfaction by certification, then rank using RANK() or DENSE_RANK() partitioned by department.

      **Return:** Certification, average project satisfaction, and rank.
40. **Project Complexity in Medium Retention Risk with Recursive Analysis**

    **Objective:**

    * Compute the average project complexity for employees with a retention risk labeled “Medium” across all job levels and track the evolution over time using a recursive CTE.

      **Requirements:**
    * Use recursive techniques to generate time-based comparisons and aggregate complexities.

      **Return:** Job level, time period, and average project complexity.

---

### **Advanced SQL Feature: Triggers & Stored Procedures**

41. **Certification Audit Trigger and Aggregate Recalculation via Stored Procedure**

    **Objective:**

    * Create a PL/pgSQL trigger that automatically logs any changes to an employee’s `certifications` field into a `certification_audit` table. Additionally, write a stored procedure that recalculates and updates a summary table containing the average innovation scores per certification whenever a change occurs.

      **Requirements:**
    * Develop a trigger function that captures old and new certification values along with a timestamp and employee id.
    * Create a stored procedure that aggregates innovation scores for each certification and updates the summary table.
    * Ensure proper error handling and transaction management within both the trigger and the stored procedure.

      **Test:** Use an UPDATE statement on the employee table to verify that the trigger fires and the stored procedure is executed correctly.

---

These updated questions now push you to employ a wide range of advanced PostgreSQL features and techniques—from recursive CTEs and advanced window functions to JSON functions, materialized views, custom user-defined functions, and integrated trigger/stored procedure solutions. Working through these challenges will not only prepare you for your interview but also deepen your overall database development expertise.

Good luck with your preparation, and feel free to ask for further hints or explanations on any specific topic!
